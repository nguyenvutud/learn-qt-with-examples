// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MPUInterface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MPUInterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MPUInterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MPUInterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MPUInterface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MPUInterface_2eproto;
namespace Interface {
class ActionInfoReq;
struct ActionInfoReqDefaultTypeInternal;
extern ActionInfoReqDefaultTypeInternal _ActionInfoReq_default_instance_;
class ActionInfoResp;
struct ActionInfoRespDefaultTypeInternal;
extern ActionInfoRespDefaultTypeInternal _ActionInfoResp_default_instance_;
class ConfigReq;
struct ConfigReqDefaultTypeInternal;
extern ConfigReqDefaultTypeInternal _ConfigReq_default_instance_;
class ConfigResp;
struct ConfigRespDefaultTypeInternal;
extern ConfigRespDefaultTypeInternal _ConfigResp_default_instance_;
class DbInfo;
struct DbInfoDefaultTypeInternal;
extern DbInfoDefaultTypeInternal _DbInfo_default_instance_;
class EndProcessReq;
struct EndProcessReqDefaultTypeInternal;
extern EndProcessReqDefaultTypeInternal _EndProcessReq_default_instance_;
class EndProcessResp;
struct EndProcessRespDefaultTypeInternal;
extern EndProcessRespDefaultTypeInternal _EndProcessResp_default_instance_;
class EndSessionReq;
struct EndSessionReqDefaultTypeInternal;
extern EndSessionReqDefaultTypeInternal _EndSessionReq_default_instance_;
class EndSessionResp;
struct EndSessionRespDefaultTypeInternal;
extern EndSessionRespDefaultTypeInternal _EndSessionResp_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class InitSessionReq;
struct InitSessionReqDefaultTypeInternal;
extern InitSessionReqDefaultTypeInternal _InitSessionReq_default_instance_;
class InitSessionResp;
struct InitSessionRespDefaultTypeInternal;
extern InitSessionRespDefaultTypeInternal _InitSessionResp_default_instance_;
class PersonInfo;
struct PersonInfoDefaultTypeInternal;
extern PersonInfoDefaultTypeInternal _PersonInfo_default_instance_;
class deviceInfo;
struct deviceInfoDefaultTypeInternal;
extern deviceInfoDefaultTypeInternal _deviceInfo_default_instance_;
}  // namespace Interface
PROTOBUF_NAMESPACE_OPEN
template<> ::Interface::ActionInfoReq* Arena::CreateMaybeMessage<::Interface::ActionInfoReq>(Arena*);
template<> ::Interface::ActionInfoResp* Arena::CreateMaybeMessage<::Interface::ActionInfoResp>(Arena*);
template<> ::Interface::ConfigReq* Arena::CreateMaybeMessage<::Interface::ConfigReq>(Arena*);
template<> ::Interface::ConfigResp* Arena::CreateMaybeMessage<::Interface::ConfigResp>(Arena*);
template<> ::Interface::DbInfo* Arena::CreateMaybeMessage<::Interface::DbInfo>(Arena*);
template<> ::Interface::EndProcessReq* Arena::CreateMaybeMessage<::Interface::EndProcessReq>(Arena*);
template<> ::Interface::EndProcessResp* Arena::CreateMaybeMessage<::Interface::EndProcessResp>(Arena*);
template<> ::Interface::EndSessionReq* Arena::CreateMaybeMessage<::Interface::EndSessionReq>(Arena*);
template<> ::Interface::EndSessionResp* Arena::CreateMaybeMessage<::Interface::EndSessionResp>(Arena*);
template<> ::Interface::Header* Arena::CreateMaybeMessage<::Interface::Header>(Arena*);
template<> ::Interface::InitSessionReq* Arena::CreateMaybeMessage<::Interface::InitSessionReq>(Arena*);
template<> ::Interface::InitSessionResp* Arena::CreateMaybeMessage<::Interface::InitSessionResp>(Arena*);
template<> ::Interface::PersonInfo* Arena::CreateMaybeMessage<::Interface::PersonInfo>(Arena*);
template<> ::Interface::deviceInfo* Arena::CreateMaybeMessage<::Interface::deviceInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Interface {

enum ErrorType : int {
  eSUCCESS = 0,
  eNO_DEVICE_FOUND = 1,
  eNO_MODEL_FOUND = 2,
  eNO_DATA_IN_DB = 3,
  eCANNOT_EXECUTE_FEATURE = 4,
  eDATA_SIZE_MISMATCH = 5,
  eNO_PERSON_FOUND = 6,
  eCANNOT_ADD_SESSION = 7,
  eCANNOT_DELETE_SESSION = 8,
  eNO_SESSION_FOUND = 9,
  eNO_SKILL_NOT_MATCH_WITH_DEVICE = 10,
  eCANNOT_ADD_PROCESS = 11,
  eCANNOT_REMOVE_PROCESS = 12,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorType_IsValid(int value);
constexpr ErrorType ErrorType_MIN = eSUCCESS;
constexpr ErrorType ErrorType_MAX = eCANNOT_REMOVE_PROCESS;
constexpr int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorType_descriptor();
template<typename T>
inline const std::string& ErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorType_descriptor(), enum_t_value);
}
inline bool ErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum ApplicationType : int {
  eEfficiency = 0,
  eErgonomy = 1,
  eQuality = 2,
  eDigitalTrainer = 3,
  ApplicationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ApplicationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ApplicationType_IsValid(int value);
constexpr ApplicationType ApplicationType_MIN = eEfficiency;
constexpr ApplicationType ApplicationType_MAX = eDigitalTrainer;
constexpr int ApplicationType_ARRAYSIZE = ApplicationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ApplicationType_descriptor();
template<typename T>
inline const std::string& ApplicationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ApplicationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ApplicationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ApplicationType_descriptor(), enum_t_value);
}
inline bool ApplicationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApplicationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ApplicationType>(
    ApplicationType_descriptor(), name, value);
}
enum ConfigStatusType : int {
  eDone = 0,
  eFailed = 1,
  eOnHold = 2,
  ConfigStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConfigStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConfigStatusType_IsValid(int value);
constexpr ConfigStatusType ConfigStatusType_MIN = eDone;
constexpr ConfigStatusType ConfigStatusType_MAX = eOnHold;
constexpr int ConfigStatusType_ARRAYSIZE = ConfigStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConfigStatusType_descriptor();
template<typename T>
inline const std::string& ConfigStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConfigStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConfigStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConfigStatusType_descriptor(), enum_t_value);
}
inline bool ConfigStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConfigStatusType>(
    ConfigStatusType_descriptor(), name, value);
}
enum ActionType : int {
  eToPosition = 0,
  eToGlue = 1,
  eToTightenLoose = 2,
  eToTighten = 3,
  eToTightenWithTorque = 4,
  eToPlug = 5,
  eToGrease = 6,
  eToCutToLength = 7,
  eToInstall = 8,
  eToApplyAdhesive = 9,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActionType_IsValid(int value);
constexpr ActionType ActionType_MIN = eToPosition;
constexpr ActionType ActionType_MAX = eToApplyAdhesive;
constexpr int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor();
template<typename T>
inline const std::string& ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionType_descriptor(), enum_t_value);
}
inline bool ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
// ===================================================================

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit constexpr Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Header& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kReqIdFieldNumber = 2,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // int32 reqId = 2;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  int32_t reqid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class ActionInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.ActionInfoReq) */ {
 public:
  inline ActionInfoReq() : ActionInfoReq(nullptr) {}
  ~ActionInfoReq() override;
  explicit constexpr ActionInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionInfoReq(const ActionInfoReq& from);
  ActionInfoReq(ActionInfoReq&& from) noexcept
    : ActionInfoReq() {
    *this = ::std::move(from);
  }

  inline ActionInfoReq& operator=(const ActionInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionInfoReq& operator=(ActionInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionInfoReq* internal_default_instance() {
    return reinterpret_cast<const ActionInfoReq*>(
               &_ActionInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ActionInfoReq& a, ActionInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionInfoReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.ActionInfoReq";
  }
  protected:
  explicit ActionInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 1,
    kProcessIdFieldNumber = 2,
  };
  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // int32 processId = 2;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.ActionInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Interface::Header* hdr_;
  int32_t processid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class ActionInfoResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.ActionInfoResp) */ {
 public:
  inline ActionInfoResp() : ActionInfoResp(nullptr) {}
  ~ActionInfoResp() override;
  explicit constexpr ActionInfoResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionInfoResp(const ActionInfoResp& from);
  ActionInfoResp(ActionInfoResp&& from) noexcept
    : ActionInfoResp() {
    *this = ::std::move(from);
  }

  inline ActionInfoResp& operator=(const ActionInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionInfoResp& operator=(ActionInfoResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionInfoResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionInfoResp* internal_default_instance() {
    return reinterpret_cast<const ActionInfoResp*>(
               &_ActionInfoResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ActionInfoResp& a, ActionInfoResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionInfoResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionInfoResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionInfoResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionInfoResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionInfoResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionInfoResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionInfoResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.ActionInfoResp";
  }
  protected:
  explicit ActionInfoResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeStampFieldNumber = 3,
    kActionNameFieldNumber = 5,
    kHdrFieldNumber = 1,
    kProcessIdFieldNumber = 2,
    kActionIdFieldNumber = 4,
  };
  // string timeStamp = 3;
  void clear_timestamp();
  const std::string& timestamp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timestamp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* timestamp);
  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(const std::string& value);
  std::string* _internal_mutable_timestamp();
  public:

  // string actionName = 5;
  void clear_actionname();
  const std::string& actionname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actionname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actionname();
  PROTOBUF_NODISCARD std::string* release_actionname();
  void set_allocated_actionname(std::string* actionname);
  private:
  const std::string& _internal_actionname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actionname(const std::string& value);
  std::string* _internal_mutable_actionname();
  public:

  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // int32 processId = 2;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // .Interface.ActionType actionId = 4;
  void clear_actionid();
  ::Interface::ActionType actionid() const;
  void set_actionid(::Interface::ActionType value);
  private:
  ::Interface::ActionType _internal_actionid() const;
  void _internal_set_actionid(::Interface::ActionType value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.ActionInfoResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actionname_;
  ::Interface::Header* hdr_;
  int32_t processid_;
  int actionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class InitSessionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.InitSessionReq) */ {
 public:
  inline InitSessionReq() : InitSessionReq(nullptr) {}
  ~InitSessionReq() override;
  explicit constexpr InitSessionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitSessionReq(const InitSessionReq& from);
  InitSessionReq(InitSessionReq&& from) noexcept
    : InitSessionReq() {
    *this = ::std::move(from);
  }

  inline InitSessionReq& operator=(const InitSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitSessionReq& operator=(InitSessionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitSessionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitSessionReq* internal_default_instance() {
    return reinterpret_cast<const InitSessionReq*>(
               &_InitSessionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InitSessionReq& a, InitSessionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InitSessionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitSessionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitSessionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitSessionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitSessionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitSessionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitSessionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.InitSessionReq";
  }
  protected:
  explicit InitSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqIdFieldNumber = 1,
  };
  // int32 reqId = 1;
  void clear_reqid();
  int32_t reqid() const;
  void set_reqid(int32_t value);
  private:
  int32_t _internal_reqid() const;
  void _internal_set_reqid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.InitSessionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t reqid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class InitSessionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.InitSessionResp) */ {
 public:
  inline InitSessionResp() : InitSessionResp(nullptr) {}
  ~InitSessionResp() override;
  explicit constexpr InitSessionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitSessionResp(const InitSessionResp& from);
  InitSessionResp(InitSessionResp&& from) noexcept
    : InitSessionResp() {
    *this = ::std::move(from);
  }

  inline InitSessionResp& operator=(const InitSessionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitSessionResp& operator=(InitSessionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitSessionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitSessionResp* internal_default_instance() {
    return reinterpret_cast<const InitSessionResp*>(
               &_InitSessionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InitSessionResp& a, InitSessionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(InitSessionResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitSessionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitSessionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitSessionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitSessionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitSessionResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitSessionResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.InitSessionResp";
  }
  protected:
  explicit InitSessionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // .Interface.ErrorType err = 2;
  void clear_err();
  ::Interface::ErrorType err() const;
  void set_err(::Interface::ErrorType value);
  private:
  ::Interface::ErrorType _internal_err() const;
  void _internal_set_err(::Interface::ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.InitSessionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Interface::Header* hdr_;
  int err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class EndSessionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.EndSessionReq) */ {
 public:
  inline EndSessionReq() : EndSessionReq(nullptr) {}
  ~EndSessionReq() override;
  explicit constexpr EndSessionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndSessionReq(const EndSessionReq& from);
  EndSessionReq(EndSessionReq&& from) noexcept
    : EndSessionReq() {
    *this = ::std::move(from);
  }

  inline EndSessionReq& operator=(const EndSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndSessionReq& operator=(EndSessionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndSessionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndSessionReq* internal_default_instance() {
    return reinterpret_cast<const EndSessionReq*>(
               &_EndSessionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EndSessionReq& a, EndSessionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EndSessionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndSessionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndSessionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndSessionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndSessionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EndSessionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndSessionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.EndSessionReq";
  }
  protected:
  explicit EndSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 1,
  };
  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // @@protoc_insertion_point(class_scope:Interface.EndSessionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Interface::Header* hdr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class EndSessionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.EndSessionResp) */ {
 public:
  inline EndSessionResp() : EndSessionResp(nullptr) {}
  ~EndSessionResp() override;
  explicit constexpr EndSessionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndSessionResp(const EndSessionResp& from);
  EndSessionResp(EndSessionResp&& from) noexcept
    : EndSessionResp() {
    *this = ::std::move(from);
  }

  inline EndSessionResp& operator=(const EndSessionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndSessionResp& operator=(EndSessionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndSessionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndSessionResp* internal_default_instance() {
    return reinterpret_cast<const EndSessionResp*>(
               &_EndSessionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EndSessionResp& a, EndSessionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(EndSessionResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndSessionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndSessionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndSessionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndSessionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EndSessionResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndSessionResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.EndSessionResp";
  }
  protected:
  explicit EndSessionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // .Interface.ErrorType err = 2;
  void clear_err();
  ::Interface::ErrorType err() const;
  void set_err(::Interface::ErrorType value);
  private:
  ::Interface::ErrorType _internal_err() const;
  void _internal_set_err(::Interface::ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.EndSessionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Interface::Header* hdr_;
  int err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class deviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.deviceInfo) */ {
 public:
  inline deviceInfo() : deviceInfo(nullptr) {}
  ~deviceInfo() override;
  explicit constexpr deviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deviceInfo(const deviceInfo& from);
  deviceInfo(deviceInfo&& from) noexcept
    : deviceInfo() {
    *this = ::std::move(from);
  }

  inline deviceInfo& operator=(const deviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline deviceInfo& operator=(deviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const deviceInfo* internal_default_instance() {
    return reinterpret_cast<const deviceInfo*>(
               &_deviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(deviceInfo& a, deviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(deviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deviceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deviceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const deviceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.deviceInfo";
  }
  protected:
  explicit deviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 1,
  };
  // string deviceId = 1;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // @@protoc_insertion_point(class_scope:Interface.deviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class PersonInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.PersonInfo) */ {
 public:
  inline PersonInfo() : PersonInfo(nullptr) {}
  ~PersonInfo() override;
  explicit constexpr PersonInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PersonInfo(const PersonInfo& from);
  PersonInfo(PersonInfo&& from) noexcept
    : PersonInfo() {
    *this = ::std::move(from);
  }

  inline PersonInfo& operator=(const PersonInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PersonInfo& operator=(PersonInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PersonInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PersonInfo* internal_default_instance() {
    return reinterpret_cast<const PersonInfo*>(
               &_PersonInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PersonInfo& a, PersonInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PersonInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PersonInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PersonInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PersonInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PersonInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PersonInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PersonInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.PersonInfo";
  }
  protected:
  explicit PersonInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 2,
    kPersonIdFieldNumber = 1,
    kTaskIdFieldNumber = 4,
    kLeftHandedFieldNumber = 3,
  };
  // repeated .Interface.deviceInfo devices = 2;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::Interface::deviceInfo* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Interface::deviceInfo >*
      mutable_devices();
  private:
  const ::Interface::deviceInfo& _internal_devices(int index) const;
  ::Interface::deviceInfo* _internal_add_devices();
  public:
  const ::Interface::deviceInfo& devices(int index) const;
  ::Interface::deviceInfo* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Interface::deviceInfo >&
      devices() const;

  // string personId = 1;
  void clear_personid();
  const std::string& personid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_personid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_personid();
  PROTOBUF_NODISCARD std::string* release_personid();
  void set_allocated_personid(std::string* personid);
  private:
  const std::string& _internal_personid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_personid(const std::string& value);
  std::string* _internal_mutable_personid();
  public:

  // string taskId = 4;
  void clear_taskid();
  const std::string& taskid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_taskid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* taskid);
  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(const std::string& value);
  std::string* _internal_mutable_taskid();
  public:

  // bool leftHanded = 3;
  void clear_lefthanded();
  bool lefthanded() const;
  void set_lefthanded(bool value);
  private:
  bool _internal_lefthanded() const;
  void _internal_set_lefthanded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.PersonInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Interface::deviceInfo > devices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr personid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taskid_;
  bool lefthanded_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class ConfigReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.ConfigReq) */ {
 public:
  inline ConfigReq() : ConfigReq(nullptr) {}
  ~ConfigReq() override;
  explicit constexpr ConfigReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigReq(const ConfigReq& from);
  ConfigReq(ConfigReq&& from) noexcept
    : ConfigReq() {
    *this = ::std::move(from);
  }

  inline ConfigReq& operator=(const ConfigReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigReq& operator=(ConfigReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigReq* internal_default_instance() {
    return reinterpret_cast<const ConfigReq*>(
               &_ConfigReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConfigReq& a, ConfigReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.ConfigReq";
  }
  protected:
  explicit ConfigReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 1,
    kPersonFieldNumber = 2,
    kDBInfoFieldNumber = 3,
    kProcessIdFieldNumber = 4,
    kAppInfoFieldNumber = 5,
  };
  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // .Interface.PersonInfo person = 2;
  bool has_person() const;
  private:
  bool _internal_has_person() const;
  public:
  void clear_person();
  const ::Interface::PersonInfo& person() const;
  PROTOBUF_NODISCARD ::Interface::PersonInfo* release_person();
  ::Interface::PersonInfo* mutable_person();
  void set_allocated_person(::Interface::PersonInfo* person);
  private:
  const ::Interface::PersonInfo& _internal_person() const;
  ::Interface::PersonInfo* _internal_mutable_person();
  public:
  void unsafe_arena_set_allocated_person(
      ::Interface::PersonInfo* person);
  ::Interface::PersonInfo* unsafe_arena_release_person();

  // .Interface.DbInfo dBInfo = 3;
  bool has_dbinfo() const;
  private:
  bool _internal_has_dbinfo() const;
  public:
  void clear_dbinfo();
  const ::Interface::DbInfo& dbinfo() const;
  PROTOBUF_NODISCARD ::Interface::DbInfo* release_dbinfo();
  ::Interface::DbInfo* mutable_dbinfo();
  void set_allocated_dbinfo(::Interface::DbInfo* dbinfo);
  private:
  const ::Interface::DbInfo& _internal_dbinfo() const;
  ::Interface::DbInfo* _internal_mutable_dbinfo();
  public:
  void unsafe_arena_set_allocated_dbinfo(
      ::Interface::DbInfo* dbinfo);
  ::Interface::DbInfo* unsafe_arena_release_dbinfo();

  // int32 processId = 4;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // .Interface.ApplicationType appInfo = 5;
  void clear_appinfo();
  ::Interface::ApplicationType appinfo() const;
  void set_appinfo(::Interface::ApplicationType value);
  private:
  ::Interface::ApplicationType _internal_appinfo() const;
  void _internal_set_appinfo(::Interface::ApplicationType value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.ConfigReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Interface::Header* hdr_;
  ::Interface::PersonInfo* person_;
  ::Interface::DbInfo* dbinfo_;
  int32_t processid_;
  int appinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class DbInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.DbInfo) */ {
 public:
  inline DbInfo() : DbInfo(nullptr) {}
  ~DbInfo() override;
  explicit constexpr DbInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DbInfo(const DbInfo& from);
  DbInfo(DbInfo&& from) noexcept
    : DbInfo() {
    *this = ::std::move(from);
  }

  inline DbInfo& operator=(const DbInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DbInfo& operator=(DbInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DbInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DbInfo* internal_default_instance() {
    return reinterpret_cast<const DbInfo*>(
               &_DbInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DbInfo& a, DbInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DbInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DbInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DbInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DbInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DbInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DbInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DbInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.DbInfo";
  }
  protected:
  explicit DbInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
    kDataBucketFieldNumber = 3,
    kValidationBucketFieldNumber = 4,
    kMeasurementFieldNumber = 5,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string port = 2;
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // string dataBucket = 3;
  void clear_databucket();
  const std::string& databucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_databucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_databucket();
  PROTOBUF_NODISCARD std::string* release_databucket();
  void set_allocated_databucket(std::string* databucket);
  private:
  const std::string& _internal_databucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_databucket(const std::string& value);
  std::string* _internal_mutable_databucket();
  public:

  // string validationBucket = 4;
  void clear_validationbucket();
  const std::string& validationbucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_validationbucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_validationbucket();
  PROTOBUF_NODISCARD std::string* release_validationbucket();
  void set_allocated_validationbucket(std::string* validationbucket);
  private:
  const std::string& _internal_validationbucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validationbucket(const std::string& value);
  std::string* _internal_mutable_validationbucket();
  public:

  // string measurement = 5;
  void clear_measurement();
  const std::string& measurement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_measurement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_measurement();
  PROTOBUF_NODISCARD std::string* release_measurement();
  void set_allocated_measurement(std::string* measurement);
  private:
  const std::string& _internal_measurement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_measurement(const std::string& value);
  std::string* _internal_mutable_measurement();
  public:

  // @@protoc_insertion_point(class_scope:Interface.DbInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr databucket_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validationbucket_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr measurement_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class ConfigResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.ConfigResp) */ {
 public:
  inline ConfigResp() : ConfigResp(nullptr) {}
  ~ConfigResp() override;
  explicit constexpr ConfigResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigResp(const ConfigResp& from);
  ConfigResp(ConfigResp&& from) noexcept
    : ConfigResp() {
    *this = ::std::move(from);
  }

  inline ConfigResp& operator=(const ConfigResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigResp& operator=(ConfigResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigResp* internal_default_instance() {
    return reinterpret_cast<const ConfigResp*>(
               &_ConfigResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ConfigResp& a, ConfigResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.ConfigResp";
  }
  protected:
  explicit ConfigResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 1,
    kCfgStatFieldNumber = 2,
    kProcessIdFieldNumber = 3,
    kErrFieldNumber = 4,
  };
  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // .Interface.ConfigStatusType cfgStat = 2;
  void clear_cfgstat();
  ::Interface::ConfigStatusType cfgstat() const;
  void set_cfgstat(::Interface::ConfigStatusType value);
  private:
  ::Interface::ConfigStatusType _internal_cfgstat() const;
  void _internal_set_cfgstat(::Interface::ConfigStatusType value);
  public:

  // int32 processId = 3;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // .Interface.ErrorType err = 4;
  void clear_err();
  ::Interface::ErrorType err() const;
  void set_err(::Interface::ErrorType value);
  private:
  ::Interface::ErrorType _internal_err() const;
  void _internal_set_err(::Interface::ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.ConfigResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Interface::Header* hdr_;
  int cfgstat_;
  int32_t processid_;
  int err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class EndProcessReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.EndProcessReq) */ {
 public:
  inline EndProcessReq() : EndProcessReq(nullptr) {}
  ~EndProcessReq() override;
  explicit constexpr EndProcessReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndProcessReq(const EndProcessReq& from);
  EndProcessReq(EndProcessReq&& from) noexcept
    : EndProcessReq() {
    *this = ::std::move(from);
  }

  inline EndProcessReq& operator=(const EndProcessReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndProcessReq& operator=(EndProcessReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndProcessReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndProcessReq* internal_default_instance() {
    return reinterpret_cast<const EndProcessReq*>(
               &_EndProcessReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EndProcessReq& a, EndProcessReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EndProcessReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndProcessReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndProcessReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndProcessReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndProcessReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EndProcessReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndProcessReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.EndProcessReq";
  }
  protected:
  explicit EndProcessReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 1,
    kProcessIdFieldNumber = 2,
  };
  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // int32 processId = 2;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.EndProcessReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Interface::Header* hdr_;
  int32_t processid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// -------------------------------------------------------------------

class EndProcessResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Interface.EndProcessResp) */ {
 public:
  inline EndProcessResp() : EndProcessResp(nullptr) {}
  ~EndProcessResp() override;
  explicit constexpr EndProcessResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndProcessResp(const EndProcessResp& from);
  EndProcessResp(EndProcessResp&& from) noexcept
    : EndProcessResp() {
    *this = ::std::move(from);
  }

  inline EndProcessResp& operator=(const EndProcessResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndProcessResp& operator=(EndProcessResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndProcessResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndProcessResp* internal_default_instance() {
    return reinterpret_cast<const EndProcessResp*>(
               &_EndProcessResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EndProcessResp& a, EndProcessResp& b) {
    a.Swap(&b);
  }
  inline void Swap(EndProcessResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndProcessResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndProcessResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndProcessResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndProcessResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EndProcessResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndProcessResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Interface.EndProcessResp";
  }
  protected:
  explicit EndProcessResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 1,
    kProcessIdFieldNumber = 2,
    kErrFieldNumber = 3,
  };
  // .Interface.Header hdr = 1;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::Interface::Header& hdr() const;
  PROTOBUF_NODISCARD ::Interface::Header* release_hdr();
  ::Interface::Header* mutable_hdr();
  void set_allocated_hdr(::Interface::Header* hdr);
  private:
  const ::Interface::Header& _internal_hdr() const;
  ::Interface::Header* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::Interface::Header* hdr);
  ::Interface::Header* unsafe_arena_release_hdr();

  // int32 processId = 2;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // .Interface.ErrorType err = 3;
  void clear_err();
  ::Interface::ErrorType err() const;
  void set_err(::Interface::ErrorType value);
  private:
  ::Interface::ErrorType _internal_err() const;
  void _internal_set_err(::Interface::ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:Interface.EndProcessResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Interface::Header* hdr_;
  int32_t processid_;
  int err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MPUInterface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// string sessionId = 1;
inline void Header::clear_sessionid() {
  sessionid_.ClearToEmpty();
}
inline const std::string& Header::sessionid() const {
  // @@protoc_insertion_point(field_get:Interface.Header.sessionId)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.Header.sessionId)
}
inline std::string* Header::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:Interface.Header.sessionId)
  return _s;
}
inline const std::string& Header::_internal_sessionid() const {
  return sessionid_.Get();
}
inline void Header::_internal_set_sessionid(const std::string& value) {
  
  sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_sessionid() {
  
  return sessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Header::release_sessionid() {
  // @@protoc_insertion_point(field_release:Interface.Header.sessionId)
  return sessionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Header::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.Header.sessionId)
}

// int32 reqId = 2;
inline void Header::clear_reqid() {
  reqid_ = 0;
}
inline int32_t Header::_internal_reqid() const {
  return reqid_;
}
inline int32_t Header::reqid() const {
  // @@protoc_insertion_point(field_get:Interface.Header.reqId)
  return _internal_reqid();
}
inline void Header::_internal_set_reqid(int32_t value) {
  
  reqid_ = value;
}
inline void Header::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:Interface.Header.reqId)
}

// -------------------------------------------------------------------

// ActionInfoReq

// .Interface.Header hdr = 1;
inline bool ActionInfoReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool ActionInfoReq::has_hdr() const {
  return _internal_has_hdr();
}
inline void ActionInfoReq::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& ActionInfoReq::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& ActionInfoReq::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.ActionInfoReq.hdr)
  return _internal_hdr();
}
inline void ActionInfoReq::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.ActionInfoReq.hdr)
}
inline ::Interface::Header* ActionInfoReq::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* ActionInfoReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.ActionInfoReq.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* ActionInfoReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* ActionInfoReq::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.ActionInfoReq.hdr)
  return _msg;
}
inline void ActionInfoReq::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.ActionInfoReq.hdr)
}

// int32 processId = 2;
inline void ActionInfoReq::clear_processid() {
  processid_ = 0;
}
inline int32_t ActionInfoReq::_internal_processid() const {
  return processid_;
}
inline int32_t ActionInfoReq::processid() const {
  // @@protoc_insertion_point(field_get:Interface.ActionInfoReq.processId)
  return _internal_processid();
}
inline void ActionInfoReq::_internal_set_processid(int32_t value) {
  
  processid_ = value;
}
inline void ActionInfoReq::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:Interface.ActionInfoReq.processId)
}

// -------------------------------------------------------------------

// ActionInfoResp

// .Interface.Header hdr = 1;
inline bool ActionInfoResp::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool ActionInfoResp::has_hdr() const {
  return _internal_has_hdr();
}
inline void ActionInfoResp::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& ActionInfoResp::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& ActionInfoResp::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.ActionInfoResp.hdr)
  return _internal_hdr();
}
inline void ActionInfoResp::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.ActionInfoResp.hdr)
}
inline ::Interface::Header* ActionInfoResp::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* ActionInfoResp::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.ActionInfoResp.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* ActionInfoResp::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* ActionInfoResp::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.ActionInfoResp.hdr)
  return _msg;
}
inline void ActionInfoResp::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.ActionInfoResp.hdr)
}

// int32 processId = 2;
inline void ActionInfoResp::clear_processid() {
  processid_ = 0;
}
inline int32_t ActionInfoResp::_internal_processid() const {
  return processid_;
}
inline int32_t ActionInfoResp::processid() const {
  // @@protoc_insertion_point(field_get:Interface.ActionInfoResp.processId)
  return _internal_processid();
}
inline void ActionInfoResp::_internal_set_processid(int32_t value) {
  
  processid_ = value;
}
inline void ActionInfoResp::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:Interface.ActionInfoResp.processId)
}

// string timeStamp = 3;
inline void ActionInfoResp::clear_timestamp() {
  timestamp_.ClearToEmpty();
}
inline const std::string& ActionInfoResp::timestamp() const {
  // @@protoc_insertion_point(field_get:Interface.ActionInfoResp.timeStamp)
  return _internal_timestamp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionInfoResp::set_timestamp(ArgT0&& arg0, ArgT... args) {
 
 timestamp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.ActionInfoResp.timeStamp)
}
inline std::string* ActionInfoResp::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:Interface.ActionInfoResp.timeStamp)
  return _s;
}
inline const std::string& ActionInfoResp::_internal_timestamp() const {
  return timestamp_.Get();
}
inline void ActionInfoResp::_internal_set_timestamp(const std::string& value) {
  
  timestamp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionInfoResp::_internal_mutable_timestamp() {
  
  return timestamp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionInfoResp::release_timestamp() {
  // @@protoc_insertion_point(field_release:Interface.ActionInfoResp.timeStamp)
  return timestamp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActionInfoResp::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  timestamp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timestamp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (timestamp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    timestamp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.ActionInfoResp.timeStamp)
}

// .Interface.ActionType actionId = 4;
inline void ActionInfoResp::clear_actionid() {
  actionid_ = 0;
}
inline ::Interface::ActionType ActionInfoResp::_internal_actionid() const {
  return static_cast< ::Interface::ActionType >(actionid_);
}
inline ::Interface::ActionType ActionInfoResp::actionid() const {
  // @@protoc_insertion_point(field_get:Interface.ActionInfoResp.actionId)
  return _internal_actionid();
}
inline void ActionInfoResp::_internal_set_actionid(::Interface::ActionType value) {
  
  actionid_ = value;
}
inline void ActionInfoResp::set_actionid(::Interface::ActionType value) {
  _internal_set_actionid(value);
  // @@protoc_insertion_point(field_set:Interface.ActionInfoResp.actionId)
}

// string actionName = 5;
inline void ActionInfoResp::clear_actionname() {
  actionname_.ClearToEmpty();
}
inline const std::string& ActionInfoResp::actionname() const {
  // @@protoc_insertion_point(field_get:Interface.ActionInfoResp.actionName)
  return _internal_actionname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionInfoResp::set_actionname(ArgT0&& arg0, ArgT... args) {
 
 actionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.ActionInfoResp.actionName)
}
inline std::string* ActionInfoResp::mutable_actionname() {
  std::string* _s = _internal_mutable_actionname();
  // @@protoc_insertion_point(field_mutable:Interface.ActionInfoResp.actionName)
  return _s;
}
inline const std::string& ActionInfoResp::_internal_actionname() const {
  return actionname_.Get();
}
inline void ActionInfoResp::_internal_set_actionname(const std::string& value) {
  
  actionname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionInfoResp::_internal_mutable_actionname() {
  
  return actionname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionInfoResp::release_actionname() {
  // @@protoc_insertion_point(field_release:Interface.ActionInfoResp.actionName)
  return actionname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ActionInfoResp::set_allocated_actionname(std::string* actionname) {
  if (actionname != nullptr) {
    
  } else {
    
  }
  actionname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actionname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (actionname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    actionname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.ActionInfoResp.actionName)
}

// -------------------------------------------------------------------

// InitSessionReq

// int32 reqId = 1;
inline void InitSessionReq::clear_reqid() {
  reqid_ = 0;
}
inline int32_t InitSessionReq::_internal_reqid() const {
  return reqid_;
}
inline int32_t InitSessionReq::reqid() const {
  // @@protoc_insertion_point(field_get:Interface.InitSessionReq.reqId)
  return _internal_reqid();
}
inline void InitSessionReq::_internal_set_reqid(int32_t value) {
  
  reqid_ = value;
}
inline void InitSessionReq::set_reqid(int32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:Interface.InitSessionReq.reqId)
}

// -------------------------------------------------------------------

// InitSessionResp

// .Interface.Header hdr = 1;
inline bool InitSessionResp::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool InitSessionResp::has_hdr() const {
  return _internal_has_hdr();
}
inline void InitSessionResp::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& InitSessionResp::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& InitSessionResp::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.InitSessionResp.hdr)
  return _internal_hdr();
}
inline void InitSessionResp::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.InitSessionResp.hdr)
}
inline ::Interface::Header* InitSessionResp::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* InitSessionResp::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.InitSessionResp.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* InitSessionResp::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* InitSessionResp::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.InitSessionResp.hdr)
  return _msg;
}
inline void InitSessionResp::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.InitSessionResp.hdr)
}

// .Interface.ErrorType err = 2;
inline void InitSessionResp::clear_err() {
  err_ = 0;
}
inline ::Interface::ErrorType InitSessionResp::_internal_err() const {
  return static_cast< ::Interface::ErrorType >(err_);
}
inline ::Interface::ErrorType InitSessionResp::err() const {
  // @@protoc_insertion_point(field_get:Interface.InitSessionResp.err)
  return _internal_err();
}
inline void InitSessionResp::_internal_set_err(::Interface::ErrorType value) {
  
  err_ = value;
}
inline void InitSessionResp::set_err(::Interface::ErrorType value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:Interface.InitSessionResp.err)
}

// -------------------------------------------------------------------

// EndSessionReq

// .Interface.Header hdr = 1;
inline bool EndSessionReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool EndSessionReq::has_hdr() const {
  return _internal_has_hdr();
}
inline void EndSessionReq::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& EndSessionReq::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& EndSessionReq::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.EndSessionReq.hdr)
  return _internal_hdr();
}
inline void EndSessionReq::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.EndSessionReq.hdr)
}
inline ::Interface::Header* EndSessionReq::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* EndSessionReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.EndSessionReq.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* EndSessionReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* EndSessionReq::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.EndSessionReq.hdr)
  return _msg;
}
inline void EndSessionReq::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.EndSessionReq.hdr)
}

// -------------------------------------------------------------------

// EndSessionResp

// .Interface.Header hdr = 1;
inline bool EndSessionResp::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool EndSessionResp::has_hdr() const {
  return _internal_has_hdr();
}
inline void EndSessionResp::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& EndSessionResp::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& EndSessionResp::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.EndSessionResp.hdr)
  return _internal_hdr();
}
inline void EndSessionResp::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.EndSessionResp.hdr)
}
inline ::Interface::Header* EndSessionResp::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* EndSessionResp::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.EndSessionResp.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* EndSessionResp::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* EndSessionResp::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.EndSessionResp.hdr)
  return _msg;
}
inline void EndSessionResp::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.EndSessionResp.hdr)
}

// .Interface.ErrorType err = 2;
inline void EndSessionResp::clear_err() {
  err_ = 0;
}
inline ::Interface::ErrorType EndSessionResp::_internal_err() const {
  return static_cast< ::Interface::ErrorType >(err_);
}
inline ::Interface::ErrorType EndSessionResp::err() const {
  // @@protoc_insertion_point(field_get:Interface.EndSessionResp.err)
  return _internal_err();
}
inline void EndSessionResp::_internal_set_err(::Interface::ErrorType value) {
  
  err_ = value;
}
inline void EndSessionResp::set_err(::Interface::ErrorType value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:Interface.EndSessionResp.err)
}

// -------------------------------------------------------------------

// deviceInfo

// string deviceId = 1;
inline void deviceInfo::clear_deviceid() {
  deviceid_.ClearToEmpty();
}
inline const std::string& deviceInfo::deviceid() const {
  // @@protoc_insertion_point(field_get:Interface.deviceInfo.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deviceInfo::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.deviceInfo.deviceId)
}
inline std::string* deviceInfo::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:Interface.deviceInfo.deviceId)
  return _s;
}
inline const std::string& deviceInfo::_internal_deviceid() const {
  return deviceid_.Get();
}
inline void deviceInfo::_internal_set_deviceid(const std::string& value) {
  
  deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* deviceInfo::_internal_mutable_deviceid() {
  
  return deviceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* deviceInfo::release_deviceid() {
  // @@protoc_insertion_point(field_release:Interface.deviceInfo.deviceId)
  return deviceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void deviceInfo::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deviceid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deviceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.deviceInfo.deviceId)
}

// -------------------------------------------------------------------

// PersonInfo

// string personId = 1;
inline void PersonInfo::clear_personid() {
  personid_.ClearToEmpty();
}
inline const std::string& PersonInfo::personid() const {
  // @@protoc_insertion_point(field_get:Interface.PersonInfo.personId)
  return _internal_personid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PersonInfo::set_personid(ArgT0&& arg0, ArgT... args) {
 
 personid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.PersonInfo.personId)
}
inline std::string* PersonInfo::mutable_personid() {
  std::string* _s = _internal_mutable_personid();
  // @@protoc_insertion_point(field_mutable:Interface.PersonInfo.personId)
  return _s;
}
inline const std::string& PersonInfo::_internal_personid() const {
  return personid_.Get();
}
inline void PersonInfo::_internal_set_personid(const std::string& value) {
  
  personid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PersonInfo::_internal_mutable_personid() {
  
  return personid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PersonInfo::release_personid() {
  // @@protoc_insertion_point(field_release:Interface.PersonInfo.personId)
  return personid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PersonInfo::set_allocated_personid(std::string* personid) {
  if (personid != nullptr) {
    
  } else {
    
  }
  personid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), personid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (personid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    personid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.PersonInfo.personId)
}

// repeated .Interface.deviceInfo devices = 2;
inline int PersonInfo::_internal_devices_size() const {
  return devices_.size();
}
inline int PersonInfo::devices_size() const {
  return _internal_devices_size();
}
inline void PersonInfo::clear_devices() {
  devices_.Clear();
}
inline ::Interface::deviceInfo* PersonInfo::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:Interface.PersonInfo.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Interface::deviceInfo >*
PersonInfo::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:Interface.PersonInfo.devices)
  return &devices_;
}
inline const ::Interface::deviceInfo& PersonInfo::_internal_devices(int index) const {
  return devices_.Get(index);
}
inline const ::Interface::deviceInfo& PersonInfo::devices(int index) const {
  // @@protoc_insertion_point(field_get:Interface.PersonInfo.devices)
  return _internal_devices(index);
}
inline ::Interface::deviceInfo* PersonInfo::_internal_add_devices() {
  return devices_.Add();
}
inline ::Interface::deviceInfo* PersonInfo::add_devices() {
  ::Interface::deviceInfo* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:Interface.PersonInfo.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Interface::deviceInfo >&
PersonInfo::devices() const {
  // @@protoc_insertion_point(field_list:Interface.PersonInfo.devices)
  return devices_;
}

// bool leftHanded = 3;
inline void PersonInfo::clear_lefthanded() {
  lefthanded_ = false;
}
inline bool PersonInfo::_internal_lefthanded() const {
  return lefthanded_;
}
inline bool PersonInfo::lefthanded() const {
  // @@protoc_insertion_point(field_get:Interface.PersonInfo.leftHanded)
  return _internal_lefthanded();
}
inline void PersonInfo::_internal_set_lefthanded(bool value) {
  
  lefthanded_ = value;
}
inline void PersonInfo::set_lefthanded(bool value) {
  _internal_set_lefthanded(value);
  // @@protoc_insertion_point(field_set:Interface.PersonInfo.leftHanded)
}

// string taskId = 4;
inline void PersonInfo::clear_taskid() {
  taskid_.ClearToEmpty();
}
inline const std::string& PersonInfo::taskid() const {
  // @@protoc_insertion_point(field_get:Interface.PersonInfo.taskId)
  return _internal_taskid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PersonInfo::set_taskid(ArgT0&& arg0, ArgT... args) {
 
 taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.PersonInfo.taskId)
}
inline std::string* PersonInfo::mutable_taskid() {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:Interface.PersonInfo.taskId)
  return _s;
}
inline const std::string& PersonInfo::_internal_taskid() const {
  return taskid_.Get();
}
inline void PersonInfo::_internal_set_taskid(const std::string& value) {
  
  taskid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PersonInfo::_internal_mutable_taskid() {
  
  return taskid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PersonInfo::release_taskid() {
  // @@protoc_insertion_point(field_release:Interface.PersonInfo.taskId)
  return taskid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PersonInfo::set_allocated_taskid(std::string* taskid) {
  if (taskid != nullptr) {
    
  } else {
    
  }
  taskid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), taskid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (taskid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    taskid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.PersonInfo.taskId)
}

// -------------------------------------------------------------------

// ConfigReq

// .Interface.Header hdr = 1;
inline bool ConfigReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool ConfigReq::has_hdr() const {
  return _internal_has_hdr();
}
inline void ConfigReq::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& ConfigReq::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& ConfigReq::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigReq.hdr)
  return _internal_hdr();
}
inline void ConfigReq::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.ConfigReq.hdr)
}
inline ::Interface::Header* ConfigReq::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* ConfigReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.ConfigReq.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* ConfigReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* ConfigReq::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.ConfigReq.hdr)
  return _msg;
}
inline void ConfigReq::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.ConfigReq.hdr)
}

// .Interface.PersonInfo person = 2;
inline bool ConfigReq::_internal_has_person() const {
  return this != internal_default_instance() && person_ != nullptr;
}
inline bool ConfigReq::has_person() const {
  return _internal_has_person();
}
inline void ConfigReq::clear_person() {
  if (GetArenaForAllocation() == nullptr && person_ != nullptr) {
    delete person_;
  }
  person_ = nullptr;
}
inline const ::Interface::PersonInfo& ConfigReq::_internal_person() const {
  const ::Interface::PersonInfo* p = person_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::PersonInfo&>(
      ::Interface::_PersonInfo_default_instance_);
}
inline const ::Interface::PersonInfo& ConfigReq::person() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigReq.person)
  return _internal_person();
}
inline void ConfigReq::unsafe_arena_set_allocated_person(
    ::Interface::PersonInfo* person) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(person_);
  }
  person_ = person;
  if (person) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.ConfigReq.person)
}
inline ::Interface::PersonInfo* ConfigReq::release_person() {
  
  ::Interface::PersonInfo* temp = person_;
  person_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::PersonInfo* ConfigReq::unsafe_arena_release_person() {
  // @@protoc_insertion_point(field_release:Interface.ConfigReq.person)
  
  ::Interface::PersonInfo* temp = person_;
  person_ = nullptr;
  return temp;
}
inline ::Interface::PersonInfo* ConfigReq::_internal_mutable_person() {
  
  if (person_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::PersonInfo>(GetArenaForAllocation());
    person_ = p;
  }
  return person_;
}
inline ::Interface::PersonInfo* ConfigReq::mutable_person() {
  ::Interface::PersonInfo* _msg = _internal_mutable_person();
  // @@protoc_insertion_point(field_mutable:Interface.ConfigReq.person)
  return _msg;
}
inline void ConfigReq::set_allocated_person(::Interface::PersonInfo* person) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete person_;
  }
  if (person) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::PersonInfo>::GetOwningArena(person);
    if (message_arena != submessage_arena) {
      person = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, person, submessage_arena);
    }
    
  } else {
    
  }
  person_ = person;
  // @@protoc_insertion_point(field_set_allocated:Interface.ConfigReq.person)
}

// .Interface.DbInfo dBInfo = 3;
inline bool ConfigReq::_internal_has_dbinfo() const {
  return this != internal_default_instance() && dbinfo_ != nullptr;
}
inline bool ConfigReq::has_dbinfo() const {
  return _internal_has_dbinfo();
}
inline void ConfigReq::clear_dbinfo() {
  if (GetArenaForAllocation() == nullptr && dbinfo_ != nullptr) {
    delete dbinfo_;
  }
  dbinfo_ = nullptr;
}
inline const ::Interface::DbInfo& ConfigReq::_internal_dbinfo() const {
  const ::Interface::DbInfo* p = dbinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::DbInfo&>(
      ::Interface::_DbInfo_default_instance_);
}
inline const ::Interface::DbInfo& ConfigReq::dbinfo() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigReq.dBInfo)
  return _internal_dbinfo();
}
inline void ConfigReq::unsafe_arena_set_allocated_dbinfo(
    ::Interface::DbInfo* dbinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dbinfo_);
  }
  dbinfo_ = dbinfo;
  if (dbinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.ConfigReq.dBInfo)
}
inline ::Interface::DbInfo* ConfigReq::release_dbinfo() {
  
  ::Interface::DbInfo* temp = dbinfo_;
  dbinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::DbInfo* ConfigReq::unsafe_arena_release_dbinfo() {
  // @@protoc_insertion_point(field_release:Interface.ConfigReq.dBInfo)
  
  ::Interface::DbInfo* temp = dbinfo_;
  dbinfo_ = nullptr;
  return temp;
}
inline ::Interface::DbInfo* ConfigReq::_internal_mutable_dbinfo() {
  
  if (dbinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::DbInfo>(GetArenaForAllocation());
    dbinfo_ = p;
  }
  return dbinfo_;
}
inline ::Interface::DbInfo* ConfigReq::mutable_dbinfo() {
  ::Interface::DbInfo* _msg = _internal_mutable_dbinfo();
  // @@protoc_insertion_point(field_mutable:Interface.ConfigReq.dBInfo)
  return _msg;
}
inline void ConfigReq::set_allocated_dbinfo(::Interface::DbInfo* dbinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dbinfo_;
  }
  if (dbinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::DbInfo>::GetOwningArena(dbinfo);
    if (message_arena != submessage_arena) {
      dbinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dbinfo, submessage_arena);
    }
    
  } else {
    
  }
  dbinfo_ = dbinfo;
  // @@protoc_insertion_point(field_set_allocated:Interface.ConfigReq.dBInfo)
}

// int32 processId = 4;
inline void ConfigReq::clear_processid() {
  processid_ = 0;
}
inline int32_t ConfigReq::_internal_processid() const {
  return processid_;
}
inline int32_t ConfigReq::processid() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigReq.processId)
  return _internal_processid();
}
inline void ConfigReq::_internal_set_processid(int32_t value) {
  
  processid_ = value;
}
inline void ConfigReq::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:Interface.ConfigReq.processId)
}

// .Interface.ApplicationType appInfo = 5;
inline void ConfigReq::clear_appinfo() {
  appinfo_ = 0;
}
inline ::Interface::ApplicationType ConfigReq::_internal_appinfo() const {
  return static_cast< ::Interface::ApplicationType >(appinfo_);
}
inline ::Interface::ApplicationType ConfigReq::appinfo() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigReq.appInfo)
  return _internal_appinfo();
}
inline void ConfigReq::_internal_set_appinfo(::Interface::ApplicationType value) {
  
  appinfo_ = value;
}
inline void ConfigReq::set_appinfo(::Interface::ApplicationType value) {
  _internal_set_appinfo(value);
  // @@protoc_insertion_point(field_set:Interface.ConfigReq.appInfo)
}

// -------------------------------------------------------------------

// DbInfo

// string ip = 1;
inline void DbInfo::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& DbInfo::ip() const {
  // @@protoc_insertion_point(field_get:Interface.DbInfo.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DbInfo::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.DbInfo.ip)
}
inline std::string* DbInfo::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Interface.DbInfo.ip)
  return _s;
}
inline const std::string& DbInfo::_internal_ip() const {
  return ip_.Get();
}
inline void DbInfo::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DbInfo::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DbInfo::release_ip() {
  // @@protoc_insertion_point(field_release:Interface.DbInfo.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DbInfo::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.DbInfo.ip)
}

// string port = 2;
inline void DbInfo::clear_port() {
  port_.ClearToEmpty();
}
inline const std::string& DbInfo::port() const {
  // @@protoc_insertion_point(field_get:Interface.DbInfo.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DbInfo::set_port(ArgT0&& arg0, ArgT... args) {
 
 port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.DbInfo.port)
}
inline std::string* DbInfo::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:Interface.DbInfo.port)
  return _s;
}
inline const std::string& DbInfo::_internal_port() const {
  return port_.Get();
}
inline void DbInfo::_internal_set_port(const std::string& value) {
  
  port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DbInfo::_internal_mutable_port() {
  
  return port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DbInfo::release_port() {
  // @@protoc_insertion_point(field_release:Interface.DbInfo.port)
  return port_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DbInfo::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (port_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    port_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.DbInfo.port)
}

// string dataBucket = 3;
inline void DbInfo::clear_databucket() {
  databucket_.ClearToEmpty();
}
inline const std::string& DbInfo::databucket() const {
  // @@protoc_insertion_point(field_get:Interface.DbInfo.dataBucket)
  return _internal_databucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DbInfo::set_databucket(ArgT0&& arg0, ArgT... args) {
 
 databucket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.DbInfo.dataBucket)
}
inline std::string* DbInfo::mutable_databucket() {
  std::string* _s = _internal_mutable_databucket();
  // @@protoc_insertion_point(field_mutable:Interface.DbInfo.dataBucket)
  return _s;
}
inline const std::string& DbInfo::_internal_databucket() const {
  return databucket_.Get();
}
inline void DbInfo::_internal_set_databucket(const std::string& value) {
  
  databucket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DbInfo::_internal_mutable_databucket() {
  
  return databucket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DbInfo::release_databucket() {
  // @@protoc_insertion_point(field_release:Interface.DbInfo.dataBucket)
  return databucket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DbInfo::set_allocated_databucket(std::string* databucket) {
  if (databucket != nullptr) {
    
  } else {
    
  }
  databucket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), databucket,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (databucket_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    databucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.DbInfo.dataBucket)
}

// string validationBucket = 4;
inline void DbInfo::clear_validationbucket() {
  validationbucket_.ClearToEmpty();
}
inline const std::string& DbInfo::validationbucket() const {
  // @@protoc_insertion_point(field_get:Interface.DbInfo.validationBucket)
  return _internal_validationbucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DbInfo::set_validationbucket(ArgT0&& arg0, ArgT... args) {
 
 validationbucket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.DbInfo.validationBucket)
}
inline std::string* DbInfo::mutable_validationbucket() {
  std::string* _s = _internal_mutable_validationbucket();
  // @@protoc_insertion_point(field_mutable:Interface.DbInfo.validationBucket)
  return _s;
}
inline const std::string& DbInfo::_internal_validationbucket() const {
  return validationbucket_.Get();
}
inline void DbInfo::_internal_set_validationbucket(const std::string& value) {
  
  validationbucket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DbInfo::_internal_mutable_validationbucket() {
  
  return validationbucket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DbInfo::release_validationbucket() {
  // @@protoc_insertion_point(field_release:Interface.DbInfo.validationBucket)
  return validationbucket_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DbInfo::set_allocated_validationbucket(std::string* validationbucket) {
  if (validationbucket != nullptr) {
    
  } else {
    
  }
  validationbucket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), validationbucket,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (validationbucket_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    validationbucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.DbInfo.validationBucket)
}

// string measurement = 5;
inline void DbInfo::clear_measurement() {
  measurement_.ClearToEmpty();
}
inline const std::string& DbInfo::measurement() const {
  // @@protoc_insertion_point(field_get:Interface.DbInfo.measurement)
  return _internal_measurement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DbInfo::set_measurement(ArgT0&& arg0, ArgT... args) {
 
 measurement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Interface.DbInfo.measurement)
}
inline std::string* DbInfo::mutable_measurement() {
  std::string* _s = _internal_mutable_measurement();
  // @@protoc_insertion_point(field_mutable:Interface.DbInfo.measurement)
  return _s;
}
inline const std::string& DbInfo::_internal_measurement() const {
  return measurement_.Get();
}
inline void DbInfo::_internal_set_measurement(const std::string& value) {
  
  measurement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DbInfo::_internal_mutable_measurement() {
  
  return measurement_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DbInfo::release_measurement() {
  // @@protoc_insertion_point(field_release:Interface.DbInfo.measurement)
  return measurement_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DbInfo::set_allocated_measurement(std::string* measurement) {
  if (measurement != nullptr) {
    
  } else {
    
  }
  measurement_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), measurement,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (measurement_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Interface.DbInfo.measurement)
}

// -------------------------------------------------------------------

// ConfigResp

// .Interface.Header hdr = 1;
inline bool ConfigResp::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool ConfigResp::has_hdr() const {
  return _internal_has_hdr();
}
inline void ConfigResp::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& ConfigResp::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& ConfigResp::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigResp.hdr)
  return _internal_hdr();
}
inline void ConfigResp::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.ConfigResp.hdr)
}
inline ::Interface::Header* ConfigResp::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* ConfigResp::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.ConfigResp.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* ConfigResp::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* ConfigResp::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.ConfigResp.hdr)
  return _msg;
}
inline void ConfigResp::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.ConfigResp.hdr)
}

// .Interface.ConfigStatusType cfgStat = 2;
inline void ConfigResp::clear_cfgstat() {
  cfgstat_ = 0;
}
inline ::Interface::ConfigStatusType ConfigResp::_internal_cfgstat() const {
  return static_cast< ::Interface::ConfigStatusType >(cfgstat_);
}
inline ::Interface::ConfigStatusType ConfigResp::cfgstat() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigResp.cfgStat)
  return _internal_cfgstat();
}
inline void ConfigResp::_internal_set_cfgstat(::Interface::ConfigStatusType value) {
  
  cfgstat_ = value;
}
inline void ConfigResp::set_cfgstat(::Interface::ConfigStatusType value) {
  _internal_set_cfgstat(value);
  // @@protoc_insertion_point(field_set:Interface.ConfigResp.cfgStat)
}

// int32 processId = 3;
inline void ConfigResp::clear_processid() {
  processid_ = 0;
}
inline int32_t ConfigResp::_internal_processid() const {
  return processid_;
}
inline int32_t ConfigResp::processid() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigResp.processId)
  return _internal_processid();
}
inline void ConfigResp::_internal_set_processid(int32_t value) {
  
  processid_ = value;
}
inline void ConfigResp::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:Interface.ConfigResp.processId)
}

// .Interface.ErrorType err = 4;
inline void ConfigResp::clear_err() {
  err_ = 0;
}
inline ::Interface::ErrorType ConfigResp::_internal_err() const {
  return static_cast< ::Interface::ErrorType >(err_);
}
inline ::Interface::ErrorType ConfigResp::err() const {
  // @@protoc_insertion_point(field_get:Interface.ConfigResp.err)
  return _internal_err();
}
inline void ConfigResp::_internal_set_err(::Interface::ErrorType value) {
  
  err_ = value;
}
inline void ConfigResp::set_err(::Interface::ErrorType value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:Interface.ConfigResp.err)
}

// -------------------------------------------------------------------

// EndProcessReq

// .Interface.Header hdr = 1;
inline bool EndProcessReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool EndProcessReq::has_hdr() const {
  return _internal_has_hdr();
}
inline void EndProcessReq::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& EndProcessReq::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& EndProcessReq::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.EndProcessReq.hdr)
  return _internal_hdr();
}
inline void EndProcessReq::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.EndProcessReq.hdr)
}
inline ::Interface::Header* EndProcessReq::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* EndProcessReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.EndProcessReq.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* EndProcessReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* EndProcessReq::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.EndProcessReq.hdr)
  return _msg;
}
inline void EndProcessReq::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.EndProcessReq.hdr)
}

// int32 processId = 2;
inline void EndProcessReq::clear_processid() {
  processid_ = 0;
}
inline int32_t EndProcessReq::_internal_processid() const {
  return processid_;
}
inline int32_t EndProcessReq::processid() const {
  // @@protoc_insertion_point(field_get:Interface.EndProcessReq.processId)
  return _internal_processid();
}
inline void EndProcessReq::_internal_set_processid(int32_t value) {
  
  processid_ = value;
}
inline void EndProcessReq::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:Interface.EndProcessReq.processId)
}

// -------------------------------------------------------------------

// EndProcessResp

// .Interface.Header hdr = 1;
inline bool EndProcessResp::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool EndProcessResp::has_hdr() const {
  return _internal_has_hdr();
}
inline void EndProcessResp::clear_hdr() {
  if (GetArenaForAllocation() == nullptr && hdr_ != nullptr) {
    delete hdr_;
  }
  hdr_ = nullptr;
}
inline const ::Interface::Header& EndProcessResp::_internal_hdr() const {
  const ::Interface::Header* p = hdr_;
  return p != nullptr ? *p : reinterpret_cast<const ::Interface::Header&>(
      ::Interface::_Header_default_instance_);
}
inline const ::Interface::Header& EndProcessResp::hdr() const {
  // @@protoc_insertion_point(field_get:Interface.EndProcessResp.hdr)
  return _internal_hdr();
}
inline void EndProcessResp::unsafe_arena_set_allocated_hdr(
    ::Interface::Header* hdr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Interface.EndProcessResp.hdr)
}
inline ::Interface::Header* EndProcessResp::release_hdr() {
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Interface::Header* EndProcessResp::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:Interface.EndProcessResp.hdr)
  
  ::Interface::Header* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::Interface::Header* EndProcessResp::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Interface::Header>(GetArenaForAllocation());
    hdr_ = p;
  }
  return hdr_;
}
inline ::Interface::Header* EndProcessResp::mutable_hdr() {
  ::Interface::Header* _msg = _internal_mutable_hdr();
  // @@protoc_insertion_point(field_mutable:Interface.EndProcessResp.hdr)
  return _msg;
}
inline void EndProcessResp::set_allocated_hdr(::Interface::Header* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hdr_;
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Interface::Header>::GetOwningArena(hdr);
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:Interface.EndProcessResp.hdr)
}

// int32 processId = 2;
inline void EndProcessResp::clear_processid() {
  processid_ = 0;
}
inline int32_t EndProcessResp::_internal_processid() const {
  return processid_;
}
inline int32_t EndProcessResp::processid() const {
  // @@protoc_insertion_point(field_get:Interface.EndProcessResp.processId)
  return _internal_processid();
}
inline void EndProcessResp::_internal_set_processid(int32_t value) {
  
  processid_ = value;
}
inline void EndProcessResp::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:Interface.EndProcessResp.processId)
}

// .Interface.ErrorType err = 3;
inline void EndProcessResp::clear_err() {
  err_ = 0;
}
inline ::Interface::ErrorType EndProcessResp::_internal_err() const {
  return static_cast< ::Interface::ErrorType >(err_);
}
inline ::Interface::ErrorType EndProcessResp::err() const {
  // @@protoc_insertion_point(field_get:Interface.EndProcessResp.err)
  return _internal_err();
}
inline void EndProcessResp::_internal_set_err(::Interface::ErrorType value) {
  
  err_ = value;
}
inline void EndProcessResp::set_err(::Interface::ErrorType value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:Interface.EndProcessResp.err)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Interface

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Interface::ErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Interface::ErrorType>() {
  return ::Interface::ErrorType_descriptor();
}
template <> struct is_proto_enum< ::Interface::ApplicationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Interface::ApplicationType>() {
  return ::Interface::ApplicationType_descriptor();
}
template <> struct is_proto_enum< ::Interface::ConfigStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Interface::ConfigStatusType>() {
  return ::Interface::ConfigStatusType_descriptor();
}
template <> struct is_proto_enum< ::Interface::ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Interface::ActionType>() {
  return ::Interface::ActionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MPUInterface_2eproto
